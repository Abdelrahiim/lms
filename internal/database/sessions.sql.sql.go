// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: sessions.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/sqlc-dev/pqtype"
)

const createSession = `-- name: CreateSession :exec
INSERT INTO user_sessions (
        id,
        user_id,
        refresh_token_hash,
        access_token_hash,
        device_name,
        device_type,
        browser,
        browser_version,
        os,
        os_version,
        ip_address,
        location,
        is_active,
        last_accessed_at,
        expires_at,
        revoked_at,
        revoked_reason,
        created_at
    )
VALUES (
        $1,
        $2,
        $3,
        $4,
        $5,
        $6,
        $7,
        $8,
        $9,
        $10,
        $11,
        $12,
        $13,
        $14,
        $15,
        $16,
        $17,
        $18
    )
`

type CreateSessionParams struct {
	ID               uuid.UUID             `json:"id"`
	UserID           uuid.UUID             `json:"userId"`
	RefreshTokenHash string                `json:"refreshTokenHash"`
	AccessTokenHash  sql.NullString        `json:"accessTokenHash"`
	DeviceName       sql.NullString        `json:"deviceName"`
	DeviceType       sql.NullString        `json:"deviceType"`
	Browser          sql.NullString        `json:"browser"`
	BrowserVersion   sql.NullString        `json:"browserVersion"`
	Os               sql.NullString        `json:"os"`
	OsVersion        sql.NullString        `json:"osVersion"`
	IpAddress        pqtype.Inet           `json:"ipAddress"`
	Location         pqtype.NullRawMessage `json:"location"`
	IsActive         sql.NullBool          `json:"isActive"`
	LastAccessedAt   sql.NullTime          `json:"lastAccessedAt"`
	ExpiresAt        time.Time             `json:"expiresAt"`
	RevokedAt        sql.NullTime          `json:"revokedAt"`
	RevokedReason    sql.NullString        `json:"revokedReason"`
	CreatedAt        sql.NullTime          `json:"createdAt"`
}

func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) error {
	_, err := q.db.ExecContext(ctx, createSession,
		arg.ID,
		arg.UserID,
		arg.RefreshTokenHash,
		arg.AccessTokenHash,
		arg.DeviceName,
		arg.DeviceType,
		arg.Browser,
		arg.BrowserVersion,
		arg.Os,
		arg.OsVersion,
		arg.IpAddress,
		arg.Location,
		arg.IsActive,
		arg.LastAccessedAt,
		arg.ExpiresAt,
		arg.RevokedAt,
		arg.RevokedReason,
		arg.CreatedAt,
	)
	return err
}

const getActiveSessions = `-- name: GetActiveSessions :many
SELECT id, user_id, refresh_token_hash, access_token_hash, device_name, device_type, browser, browser_version, os, os_version, ip_address, location, is_active, last_accessed_at, expires_at, revoked_at, revoked_reason, created_at
FROM user_sessions
WHERE user_id = $1
    AND is_active = $2
`

type GetActiveSessionsParams struct {
	UserID   uuid.UUID    `json:"userId"`
	IsActive sql.NullBool `json:"isActive"`
}

func (q *Queries) GetActiveSessions(ctx context.Context, arg GetActiveSessionsParams) ([]UserSession, error) {
	rows, err := q.db.QueryContext(ctx, getActiveSessions, arg.UserID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UserSession{}
	for rows.Next() {
		var i UserSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.RefreshTokenHash,
			&i.AccessTokenHash,
			&i.DeviceName,
			&i.DeviceType,
			&i.Browser,
			&i.BrowserVersion,
			&i.Os,
			&i.OsVersion,
			&i.IpAddress,
			&i.Location,
			&i.IsActive,
			&i.LastAccessedAt,
			&i.ExpiresAt,
			&i.RevokedAt,
			&i.RevokedReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionByRefreshToken = `-- name: GetSessionByRefreshToken :one
SELECT id, user_id, refresh_token_hash, access_token_hash, device_name, device_type, browser, browser_version, os, os_version, ip_address, location, is_active, last_accessed_at, expires_at, revoked_at, revoked_reason, created_at
FROM user_sessions
WHERE refresh_token_hash = $1
    AND is_active = TRUE
`

func (q *Queries) GetSessionByRefreshToken(ctx context.Context, refreshTokenHash string) (UserSession, error) {
	row := q.db.QueryRowContext(ctx, getSessionByRefreshToken, refreshTokenHash)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshTokenHash,
		&i.AccessTokenHash,
		&i.DeviceName,
		&i.DeviceType,
		&i.Browser,
		&i.BrowserVersion,
		&i.Os,
		&i.OsVersion,
		&i.IpAddress,
		&i.Location,
		&i.IsActive,
		&i.LastAccessedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
		&i.RevokedReason,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionByUserID = `-- name: GetSessionByUserID :one
SELECT id, user_id, refresh_token_hash, access_token_hash, device_name, device_type, browser, browser_version, os, os_version, ip_address, location, is_active, last_accessed_at, expires_at, revoked_at, revoked_reason, created_at
FROM user_sessions
WHERE user_id = $1
    AND ip_address = $2
    AND is_active = TRUE
`

type GetSessionByUserIDParams struct {
	UserID    uuid.UUID   `json:"userId"`
	IpAddress pqtype.Inet `json:"ipAddress"`
}

func (q *Queries) GetSessionByUserID(ctx context.Context, arg GetSessionByUserIDParams) (UserSession, error) {
	row := q.db.QueryRowContext(ctx, getSessionByUserID, arg.UserID, arg.IpAddress)
	var i UserSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RefreshTokenHash,
		&i.AccessTokenHash,
		&i.DeviceName,
		&i.DeviceType,
		&i.Browser,
		&i.BrowserVersion,
		&i.Os,
		&i.OsVersion,
		&i.IpAddress,
		&i.Location,
		&i.IsActive,
		&i.LastAccessedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
		&i.RevokedReason,
		&i.CreatedAt,
	)
	return i, err
}

const revokeSession = `-- name: RevokeSession :exec
UPDATE user_sessions
SET is_active = FALSE,
    revoked_at = $1,
    revoked_reason = $2
WHERE id = $3
`

type RevokeSessionParams struct {
	RevokedAt     sql.NullTime   `json:"revokedAt"`
	RevokedReason sql.NullString `json:"revokedReason"`
	ID            uuid.UUID      `json:"id"`
}

func (q *Queries) RevokeSession(ctx context.Context, arg RevokeSessionParams) error {
	_, err := q.db.ExecContext(ctx, revokeSession, arg.RevokedAt, arg.RevokedReason, arg.ID)
	return err
}

const updateSessionLastAccessedAt = `-- name: UpdateSessionLastAccessedAt :exec
UPDATE user_sessions
SET last_accessed_at = $1
WHERE id = $2
`

type UpdateSessionLastAccessedAtParams struct {
	LastAccessedAt sql.NullTime `json:"lastAccessedAt"`
	ID             uuid.UUID    `json:"id"`
}

func (q *Queries) UpdateSessionLastAccessedAt(ctx context.Context, arg UpdateSessionLastAccessedAtParams) error {
	_, err := q.db.ExecContext(ctx, updateSessionLastAccessedAt, arg.LastAccessedAt, arg.ID)
	return err
}
